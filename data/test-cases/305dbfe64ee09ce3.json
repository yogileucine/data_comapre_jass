{"uid":"305dbfe64ee09ce3","name":"test_compare_database","fullName":"tests.database.test_db.TestDataBaseConnection#test_compare_database","historyId":"f05e8ceffdd8028971962ff0d41322f8","time":{"start":1702029737100,"stop":1702030639839,"duration":902739},"status":"failed","statusMessage":"AssertionError: mlab & feature.a Database tables details are not matching\nassert False","statusTrace":"self = <test_db.TestDataBaseConnection object at 0x000001EB7F97C810>\n\n    @pytest.mark.compare_database\n    def test_compare_database(self):\n        assert_flag = True\n        data_match = []\n        missing_tables = []\n        missing_column = []\n        column_data_type = []\n        sql_type_error_query_list = []\n        type_error_col = []\n    \n        with open('util/host_detail.json') as file:\n            data = json.load(file)\n    \n        old_database = data[\"old_dbname\"]\n        new_database = data[\"new_dbname\"]\n    \n        for sql_query in Sql:\n            data_base_connect = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database),\n                                                               sql_query.value)\n            data_base_connect1 = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database),\n                                                                sql_query.value)\n    \n            data_query_list = list(set(data_base_connect1[\"sql_query_list\"] + data_base_connect[\"sql_query_list\"]))\n    \n            for sql in data_query_list:\n    \n                list_col = []\n                try:\n                    old_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database),\n                                                              sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(old_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n    \n                    continue\n    \n                try:\n                    new_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database),\n                                                              sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(new_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n                    continue\n    \n                try:\n                    if new_data.columns.difference(old_data.columns).any():\n                        assert_flag = False\n                        diff_col = new_data.columns.difference(old_data.columns)\n                        missing_column.append(\"Instance: \" + str(old_database) + \",\" + \" Column: \" + str(\n                            diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                            sql.replace('select * from ', '')))\n    \n                    if old_data.columns.difference(new_data.columns).any():\n                        assert_flag = False\n                        diff_col = old_data.columns.difference(new_data.columns)\n                        missing_column.append(\"Instance: \" + str(new_database) + \",\" + \" Column: \" + str(\n                            diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                            sql.replace('select * from ', '')))\n    \n                except Exception as e:\n                    print(e)\n    \n                try:\n    \n                    filter_new_data = new_data.loc[:, ~new_data.columns.isin(list_col)]\n                    filter_old_data = old_data.loc[:, ~old_data.columns.isin(list_col)]\n    \n                    df_diff = None\n                    if not filter_new_data.equals(filter_old_data):\n                        try:\n                            df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n                            df_diff = df_diff[df_diff['_merge'] != 'both']\n                            df_diff = df_diff.rename(columns={'_merge': 'database'})\n                            df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only',\n                                                                                  str(new_database)).str.replace(\n                                'right_only', str(old_database))\n                        except TypeError:\n                            sql_type_error_query = \"select * from \" + sql.replace('select * from ', '')\n                            sql_type_error_query_list.append(sql_type_error_query)\n                            allure.attach(\"Table Name : \" + str(sql.replace('select * from ', '')),\n                                          name='Type Error in Database Table', attachment_type=allure.attachment_type.TEXT)\n                            pass\n    \n                        if df_diff is not None and df_diff[\"database\"].isin([str(old_database), str(new_database)]).any():\n                            assert_flag = False\n                            df_diff_html = df_diff.to_html()\n                            allure.attach(df_diff_html, name='Difference Between Two Database tables : ' +\n                                                             str(sql.replace('select * from ', '')),\n                                          attachment_type=allure.attachment_type.HTML)\n                    else:\n                        data_match.append('Database Data Match : ' + str(sql.replace('select * from ', '')))\n                except Exception as e:\n                    print(e)\n    \n            for sql_data_type in data_base_connect[\"sql_data_type_query_list\"]:\n                old_data = \\\n                    DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database), sql_data_type)[\n                        \"db_data\"]\n                new_data = \\\n                    DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database), sql_data_type)[\n                        \"db_data\"]\n    \n                common_columns = set(old_data['column_name']).intersection(set(new_data['column_name']))\n    \n                for column in common_columns:\n                    db_type1 = old_data.loc[old_data['column_name'] == column, 'data_type'].iloc[0]\n                    db_type2 = new_data.loc[new_data['column_name'] == column, 'data_type'].iloc[0]\n                    if db_type1 != db_type2:\n                        assert_flag = False\n                        sql_table = \"select column_name, data_type from information_schema.columns where table_name = \"\n                        df = f\"From Table: {str(sql_data_type.replace(sql_table, ''))}, Column '{column}' has \" \\\n                             f\"different datatypes: Database 1: {db_type1},  Database 2: {db_type2}\"\n                        column_data_type.append(df)\n    \n            def dict_to_tuple(d):\n                if isinstance(d, dict):\n                    result = []\n                    for k, v in d.items():\n                        tuple_v = dict_to_tuple(v)\n                        result.append((k, tuple_v))\n                    return tuple(result)\n                elif isinstance(d, list):\n                    return tuple(dict_to_tuple(x) for x in d)\n                else:\n                    return d\n    \n            for sql_type in sql_type_error_query_list:\n                old_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database),\n                                                          sql_type)[\"db_data\"]\n                new_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database),\n                                                          sql_type)[\"db_data\"]\n    \n                old_col_to_tuple = old_data.applymap(dict_to_tuple)\n                new_col_to_tuple = new_data.applymap(dict_to_tuple)\n    \n                diff_col = old_col_to_tuple.columns.difference(new_col_to_tuple.columns)\n    \n                type_error_col.extend(diff_col.values)\n    \n                filter_old_data = old_col_to_tuple.loc[:, ~old_col_to_tuple.columns.isin(type_error_col)]\n                filter_new_data = new_col_to_tuple.loc[:, ~new_col_to_tuple.columns.isin(type_error_col)]\n    \n                df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n    \n                # abc = pd.concat([])\n    \n                df_diff = df_diff[df_diff[\"_merge\"] != \"both\"]\n                df_diff = df_diff.rename(columns={'_merge': 'database'})\n                df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only', str(new_database)).str.replace(\n                    'right_only', str(old_database))\n    \n                allure.attach(df_diff.to_html(), name='Difference between two Database tables : ' +\n                                                      str(sql_type.replace('select * from ', '')),\n                              attachment_type=allure.attachment_type.HTML)\n    \n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(old_database))\n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(new_database))\n    \n            database_data_match = '\\n'.join(data_match)\n            allure.attach(str(database_data_match), name='Database Data Match',\n                          attachment_type=allure.attachment_type.TEXT)\n            missing_tables = '\\n'.join(missing_tables)\n            allure.attach(str(missing_tables), name='Missing Tables from database',\n                          attachment_type=allure.attachment_type.TEXT)\n            missing_column = '\\n'.join(missing_column)\n            allure.attach(str(missing_column), name='Missing Column in Database table',\n                          attachment_type=allure.attachment_type.TEXT)\n            database_column_datatype = '\\n'.join(column_data_type)\n            allure.attach(str(database_column_datatype), name='Database Columns Datatype not matching',\n                          attachment_type=allure.attachment_type.TEXT)\n    \n            # Check for missing tables and other conditions\n            if len(missing_tables) != 0:\n>               assert assert_flag, f\"{old_database} & {new_database} Database tables details are not matching\"\nE               AssertionError: mlab & feature.a Database tables details are not matching\nE               assert False\n\ntests\\database\\test_db.py:189: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"load_env","time":{"start":1702029737097,"stop":1702029737100,"duration":3},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"testStage":{"status":"failed","statusMessage":"AssertionError: mlab & feature.a Database tables details are not matching\nassert False","statusTrace":"self = <test_db.TestDataBaseConnection object at 0x000001EB7F97C810>\n\n    @pytest.mark.compare_database\n    def test_compare_database(self):\n        assert_flag = True\n        data_match = []\n        missing_tables = []\n        missing_column = []\n        column_data_type = []\n        sql_type_error_query_list = []\n        type_error_col = []\n    \n        with open('util/host_detail.json') as file:\n            data = json.load(file)\n    \n        old_database = data[\"old_dbname\"]\n        new_database = data[\"new_dbname\"]\n    \n        for sql_query in Sql:\n            data_base_connect = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database),\n                                                               sql_query.value)\n            data_base_connect1 = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database),\n                                                                sql_query.value)\n    \n            data_query_list = list(set(data_base_connect1[\"sql_query_list\"] + data_base_connect[\"sql_query_list\"]))\n    \n            for sql in data_query_list:\n    \n                list_col = []\n                try:\n                    old_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database),\n                                                              sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(old_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n    \n                    continue\n    \n                try:\n                    new_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database),\n                                                              sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(new_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n                    continue\n    \n                try:\n                    if new_data.columns.difference(old_data.columns).any():\n                        assert_flag = False\n                        diff_col = new_data.columns.difference(old_data.columns)\n                        missing_column.append(\"Instance: \" + str(old_database) + \",\" + \" Column: \" + str(\n                            diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                            sql.replace('select * from ', '')))\n    \n                    if old_data.columns.difference(new_data.columns).any():\n                        assert_flag = False\n                        diff_col = old_data.columns.difference(new_data.columns)\n                        missing_column.append(\"Instance: \" + str(new_database) + \",\" + \" Column: \" + str(\n                            diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                            sql.replace('select * from ', '')))\n    \n                except Exception as e:\n                    print(e)\n    \n                try:\n    \n                    filter_new_data = new_data.loc[:, ~new_data.columns.isin(list_col)]\n                    filter_old_data = old_data.loc[:, ~old_data.columns.isin(list_col)]\n    \n                    df_diff = None\n                    if not filter_new_data.equals(filter_old_data):\n                        try:\n                            df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n                            df_diff = df_diff[df_diff['_merge'] != 'both']\n                            df_diff = df_diff.rename(columns={'_merge': 'database'})\n                            df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only',\n                                                                                  str(new_database)).str.replace(\n                                'right_only', str(old_database))\n                        except TypeError:\n                            sql_type_error_query = \"select * from \" + sql.replace('select * from ', '')\n                            sql_type_error_query_list.append(sql_type_error_query)\n                            allure.attach(\"Table Name : \" + str(sql.replace('select * from ', '')),\n                                          name='Type Error in Database Table', attachment_type=allure.attachment_type.TEXT)\n                            pass\n    \n                        if df_diff is not None and df_diff[\"database\"].isin([str(old_database), str(new_database)]).any():\n                            assert_flag = False\n                            df_diff_html = df_diff.to_html()\n                            allure.attach(df_diff_html, name='Difference Between Two Database tables : ' +\n                                                             str(sql.replace('select * from ', '')),\n                                          attachment_type=allure.attachment_type.HTML)\n                    else:\n                        data_match.append('Database Data Match : ' + str(sql.replace('select * from ', '')))\n                except Exception as e:\n                    print(e)\n    \n            for sql_data_type in data_base_connect[\"sql_data_type_query_list\"]:\n                old_data = \\\n                    DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database), sql_data_type)[\n                        \"db_data\"]\n                new_data = \\\n                    DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database), sql_data_type)[\n                        \"db_data\"]\n    \n                common_columns = set(old_data['column_name']).intersection(set(new_data['column_name']))\n    \n                for column in common_columns:\n                    db_type1 = old_data.loc[old_data['column_name'] == column, 'data_type'].iloc[0]\n                    db_type2 = new_data.loc[new_data['column_name'] == column, 'data_type'].iloc[0]\n                    if db_type1 != db_type2:\n                        assert_flag = False\n                        sql_table = \"select column_name, data_type from information_schema.columns where table_name = \"\n                        df = f\"From Table: {str(sql_data_type.replace(sql_table, ''))}, Column '{column}' has \" \\\n                             f\"different datatypes: Database 1: {db_type1},  Database 2: {db_type2}\"\n                        column_data_type.append(df)\n    \n            def dict_to_tuple(d):\n                if isinstance(d, dict):\n                    result = []\n                    for k, v in d.items():\n                        tuple_v = dict_to_tuple(v)\n                        result.append((k, tuple_v))\n                    return tuple(result)\n                elif isinstance(d, list):\n                    return tuple(dict_to_tuple(x) for x in d)\n                else:\n                    return d\n    \n            for sql_type in sql_type_error_query_list:\n                old_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(old_database),\n                                                          sql_type)[\"db_data\"]\n                new_data = DataBaseConnection.get_db_data(DataBaseConnection.setup_connection(new_database),\n                                                          sql_type)[\"db_data\"]\n    \n                old_col_to_tuple = old_data.applymap(dict_to_tuple)\n                new_col_to_tuple = new_data.applymap(dict_to_tuple)\n    \n                diff_col = old_col_to_tuple.columns.difference(new_col_to_tuple.columns)\n    \n                type_error_col.extend(diff_col.values)\n    \n                filter_old_data = old_col_to_tuple.loc[:, ~old_col_to_tuple.columns.isin(type_error_col)]\n                filter_new_data = new_col_to_tuple.loc[:, ~new_col_to_tuple.columns.isin(type_error_col)]\n    \n                df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n    \n                # abc = pd.concat([])\n    \n                df_diff = df_diff[df_diff[\"_merge\"] != \"both\"]\n                df_diff = df_diff.rename(columns={'_merge': 'database'})\n                df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only', str(new_database)).str.replace(\n                    'right_only', str(old_database))\n    \n                allure.attach(df_diff.to_html(), name='Difference between two Database tables : ' +\n                                                      str(sql_type.replace('select * from ', '')),\n                              attachment_type=allure.attachment_type.HTML)\n    \n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(old_database))\n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(new_database))\n    \n            database_data_match = '\\n'.join(data_match)\n            allure.attach(str(database_data_match), name='Database Data Match',\n                          attachment_type=allure.attachment_type.TEXT)\n            missing_tables = '\\n'.join(missing_tables)\n            allure.attach(str(missing_tables), name='Missing Tables from database',\n                          attachment_type=allure.attachment_type.TEXT)\n            missing_column = '\\n'.join(missing_column)\n            allure.attach(str(missing_column), name='Missing Column in Database table',\n                          attachment_type=allure.attachment_type.TEXT)\n            database_column_datatype = '\\n'.join(column_data_type)\n            allure.attach(str(database_column_datatype), name='Database Columns Datatype not matching',\n                          attachment_type=allure.attachment_type.TEXT)\n    \n            # Check for missing tables and other conditions\n            if len(missing_tables) != 0:\n>               assert assert_flag, f\"{old_database} & {new_database} Database tables details are not matching\"\nE               AssertionError: mlab & feature.a Database tables details are not matching\nE               assert False\n\ntests\\database\\test_db.py:189: AssertionError","steps":[],"attachments":[{"uid":"676b2ab196d94dc9","name":"Type Error in Database Table","source":"676b2ab196d94dc9.txt","type":"text/plain","size":33},{"uid":"7cd82c4143560ffb","name":"Difference Between Two Database tables : migrations","source":"7cd82c4143560ffb.html","type":"text/html","size":5447},{"uid":"1ec99a60e76b0367","name":"Difference Between Two Database tables : document_version","source":"1ec99a60e76b0367.html","type":"text/html","size":3268},{"uid":"18c01b89965c093","name":"Difference Between Two Database tables : version","source":"18c01b89965c093.html","type":"text/html","size":446},{"uid":"df3b9054eb269b78","name":"Difference Between Two Database tables : user_session","source":"df3b9054eb269b78.html","type":"text/html","size":1935},{"uid":"83edaa5f91ef5daa","name":"Type Error in Database Table","source":"83edaa5f91ef5daa.txt","type":"text/plain","size":54},{"uid":"9b018ec5c25888a0","name":"Difference Between Two Database tables : approval_policy_settings","source":"9b018ec5c25888a0.html","type":"text/html","size":5508},{"uid":"619665971742ac03","name":"Difference Between Two Database tables : on_demand_versioning","source":"619665971742ac03.html","type":"text/html","size":947},{"uid":"d5fd688a5b3975b1","name":"Difference Between Two Database tables : password_policy_settings","source":"d5fd688a5b3975b1.html","type":"text/html","size":1715},{"uid":"f6c5459341127825","name":"Difference Between Two Database tables : log_item","source":"f6c5459341127825.html","type":"text/html","size":66269},{"uid":"2a8c849ab4d3df7d","name":"Type Error in Database Table","source":"2a8c849ab4d3df7d.txt","type":"text/plain","size":34},{"uid":"8f6f53e996baaca9","name":"Difference Between Two Database tables : login_attempt","source":"8f6f53e996baaca9.html","type":"text/html","size":3006},{"uid":"bd04f56e3d82dbb7","name":"Type Error in Database Table","source":"bd04f56e3d82dbb7.txt","type":"text/plain","size":31},{"uid":"1cbb310d64c4a389","name":"Difference Between Two Database tables : user_role","source":"1cbb310d64c4a389.html","type":"text/html","size":66986},{"uid":"de2ba186ec539a","name":"Difference Between Two Database tables : variable","source":"de2ba186ec539a.html","type":"text/html","size":3686},{"uid":"8f35d46846498f2f","name":"Difference Between Two Database tables : report_info","source":"8f35d46846498f2f.html","type":"text/html","size":3784},{"uid":"5791efcd52adb5f8","name":"Difference Between Two Database tables : reset_password_token","source":"5791efcd52adb5f8.html","type":"text/html","size":858},{"uid":"fc5a435ffdd3a491","name":"Difference Between Two Database tables : user_password_salted","source":"fc5a435ffdd3a491.html","type":"text/html","size":480},{"uid":"fb91af49c6f42af2","name":"Type Error in Database Table","source":"fb91af49c6f42af2.txt","type":"text/plain","size":44},{"uid":"a98d1412fa8b6ad5","name":"Difference between two Database tables : on_demand_inspection","source":"a98d1412fa8b6ad5.html","type":"text/html","size":1161012},{"uid":"a4dd0c4a03bf59a9","name":"Difference between two Database tables : on_demand_equipment_wise_sampling_profile","source":"a4dd0c4a03bf59a9.html","type":"text/html","size":2759718},{"uid":"25eea28814952389","name":"Difference between two Database tables : cleaning_limit_policy","source":"25eea28814952389.html","type":"text/html","size":10204},{"uid":"85c8fab39a8e3095","name":"Difference between two Database tables : on_demand_protocol","source":"85c8fab39a8e3095.html","type":"text/html","size":30220721},{"uid":"23575ed2bc36a3be","name":"Difference between two Database tables : on_demand_protocol_verification","source":"23575ed2bc36a3be.html","type":"text/html","size":1814147},{"uid":"8e71fc8b000bb062","name":"Database Data Match","source":"8e71fc8b000bb062.txt","type":"text/plain","size":5006},{"uid":"5cabb56bafe54036","name":"Missing Tables from database","source":"5cabb56bafe54036.txt","type":"text/plain","size":2233},{"uid":"9f1eacb2ee305ccc","name":"Missing Column in Database table","source":"9f1eacb2ee305ccc.txt","type":"text/plain","size":3046},{"uid":"3063986a67bf2b88","name":"Database Columns Datatype not matching","source":"3063986a67bf2b88.txt","type":"text/plain","size":0}],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":28},"afterStages":[],"labels":[{"name":"tag","value":"compare_database"},{"name":"parentSuite","value":"tests.database"},{"name":"suite","value":"test_db"},{"name":"subSuite","value":"TestDataBaseConnection"},{"name":"host","value":"DESKTOP-ESU2KLG"},{"name":"thread","value":"17788-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.database.test_db"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":["compare_database"]},"source":"305dbfe64ee09ce3.json","parameterValues":[]}