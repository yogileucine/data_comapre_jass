{"uid":"6c5a27f3b3eee3b2","name":"test_compare_database","fullName":"tests.database.test_db.TestDataBaseConnection#test_compare_database","historyId":"f05e8ceffdd8028971962ff0d41322f8","time":{"start":1734005178839,"stop":1734005282765,"duration":103926},"status":"failed","statusMessage":"AssertionError: amneal_dwi & amneal_migrated_dwi Database tables details are not matching\nassert False","statusTrace":"self = <test_db.TestDataBaseConnection object at 0x000001BD2E41F110>\n\n    @pytest.mark.compare_database\n    def test_compare_database(self):\n        assert_flag = True\n        data_match = []\n        missing_tables = []\n        missing_column = []\n        column_data_type = []\n        sql_type_error_query_list = []\n        type_error_col = []\n    \n        with open('util/host_detail.json') as file:\n            data = json.load(file)\n    \n        old_database = data[\"old_dbname\"]\n        new_database = data[\"new_dbname\"]\n    \n        # Create database connections once\n        old_db_connection = DataBaseConnection.setup_connection(old_database)\n        new_db_connection = DataBaseConnection.setup_connection(new_database)\n    \n        for sql_query in Sql:\n            data_base_connect = DataBaseConnection.get_db_data(old_db_connection, sql_query.value)\n            data_base_connect1 = DataBaseConnection.get_db_data(new_db_connection, sql_query.value)\n    \n            old_tables = set(data_base_connect[\"sql_query_list\"])\n            new_tables = set(data_base_connect1[\"sql_query_list\"])\n    \n            # Tables in old database but not in new database\n            tables_in_old_not_in_new = old_tables - new_tables\n            for table in tables_in_old_not_in_new:\n                missing_tables.append(f\"Database: {old_database}, Table Name: {table.replace('select * from ', '')}\")\n    \n            # Tables in new database but not in old database\n            tables_in_new_not_in_old = new_tables - old_tables\n            for table in tables_in_new_not_in_old:\n                missing_tables.append(f\"Database: {new_database}, Table Name: {table.replace('select * from ', '')}\")\n    \n            # Tables present in both databases\n            data_query_list = list(old_tables & new_tables)\n    \n            for sql in data_query_list:\n                list_col = []\n                try:\n                    old_data = DataBaseConnection.get_db_data(old_db_connection, sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(old_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n                    continue\n                except Exception as e:\n                    assert_flag = False\n                    missing_tables.append(\n                        f\"Error fetching data from {old_database} for table {sql.replace('select * from ', '')}: {str(e)}\")\n                    continue\n    \n                try:\n                    new_data = DataBaseConnection.get_db_data(new_db_connection, sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(new_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n                    continue\n                except Exception as e:\n                    assert_flag = False\n                    missing_tables.append(\n                        f\"Error fetching data from {new_database} for table {sql.replace('select * from ', '')}: {str(e)}\")\n                    continue\n    \n                if new_data is None or old_data is None:\n                    assert_flag = False\n                    missing_tables.append(f\"Data retrieval failed for table: {sql.replace('select * from ', '')}\")\n                    continue\n    \n                if new_data.columns.difference(old_data.columns).any():\n                    assert_flag = False\n                    diff_col = new_data.columns.difference(old_data.columns)\n                    missing_column.append(\"Instance: \" + str(old_database) + \",\" + \" Column: \" + str(\n                        diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                        sql.replace('select * from ', '')))\n    \n                if old_data.columns.difference(new_data.columns).any():\n                    assert_flag = False\n                    diff_col = old_data.columns.difference(new_data.columns)\n                    missing_column.append(\"Instance: \" + str(new_database) + \",\" + \" Column: \" + str(\n                        diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                        sql.replace('select * from ', '')))\n    \n                try:\n                    filter_new_data = new_data.loc[:, ~new_data.columns.isin(list_col)]\n                    filter_old_data = old_data.loc[:, ~old_data.columns.isin(list_col)]\n    \n                    df_diff = None\n                    if not filter_new_data.equals(filter_old_data):\n                        try:\n                            df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n                            df_diff = df_diff[df_diff['_merge'] != 'both']\n                            df_diff = df_diff.rename(columns={'_merge': 'database'})\n                            df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only',\n                                                                                  str(new_database)).str.replace(\n                                'right_only', str(old_database))\n                        except TypeError:\n                            sql_type_error_query = \"select * from \" + sql.replace('select * from ', '')\n                            sql_type_error_query_list.append(sql_type_error_query)\n                            allure.attach(\"Table Name : \" + str(sql.replace('select * from ', '')),\n                                          name='Type Error in Database Table',\n                                          attachment_type=allure.attachment_type.TEXT)\n                            pass\n    \n                        if df_diff is not None and df_diff[\"database\"].isin(\n                                [str(old_database), str(new_database)]).any():\n                            assert_flag = False\n                            df_diff_html = df_diff.to_html()\n                            allure.attach(df_diff_html, name='Difference Between Two Database tables : ' +\n                                                             str(sql.replace('select * from ', '')),\n                                          attachment_type=allure.attachment_type.HTML)\n                    else:\n                        data_match.append('Database Data Match : ' + str(sql.replace('select * from ', '')))\n                except Exception as e:\n                    print(e, sql)\n    \n            for sql_data_type in data_base_connect[\"sql_data_type_query_list\"]:\n                old_data = \\\n                    DataBaseConnection.get_db_data(old_db_connection, sql_data_type)[\"db_data\"]\n                new_data = \\\n                    DataBaseConnection.get_db_data(new_db_connection, sql_data_type)[\"db_data\"]\n                common_columns = None\n                if old_data is not None and new_data is not None:\n                    try:\n                        common_columns = set(old_data['column_name']).intersection(set(new_data['column_name']))\n                    except Exception as e:\n                        print(e, sql)\n                        continue\n                else:\n                    allure.attach(f\"Missing data for table: {sql_data_type}\", name='Missing Data',\n                                  attachment_type=allure.attachment_type.TEXT)\n    \n                try:\n                    for column in common_columns:\n                        db_type1 = old_data.loc[old_data['column_name'] == column, 'data_type'].iloc[0]\n                        db_type2 = new_data.loc[old_data['column_name'] == column, 'data_type'].iloc[0]\n                        if db_type1 != db_type2:\n                            assert_flag = False\n                            sql_table = \"select column_name, data_type from information_schema.columns where table_name = \"\n                            df = f\"From Table: {str(sql_data_type.replace(sql_table, ''))}, Column '{column}' has \" \\\n                                 f\"different datatypes: Database 1: {db_type1},  Database 2: {db_type2}\"\n                            column_data_type.append(df)\n                except Exception as e:\n                    print(e, sql)\n    \n            def dict_to_tuple(d):\n                if isinstance(d, dict):\n                    return tuple(sorted((k, dict_to_tuple(v)) for k, v in d.items()))\n                elif isinstance(d, list):\n                    return tuple(dict_to_tuple(x) for x in d)\n                else:\n                    return d\n    \n            for sql_type in sql_type_error_query_list:\n                print(sql_type, \"sql_error\")\n                old_data = DataBaseConnection.get_db_data(old_db_connection, sql_type)[\"db_data\"]\n                new_data = DataBaseConnection.get_db_data(new_db_connection, sql_type)[\"db_data\"]\n    \n                # Apply dict_to_tuple for JSON columns\n                old_col_to_tuple = old_data.applymap(\n                    lambda x: dict_to_tuple(x) if isinstance(x, dict) or isinstance(x, list) else x)\n                new_col_to_tuple = new_data.applymap(\n                    lambda x: dict_to_tuple(x) if isinstance(x, dict) or isinstance(x, list) else x)\n    \n                # Identify columns with type errors\n                diff_col = old_col_to_tuple.columns.difference(new_col_to_tuple.columns)\n                type_error_col.extend(diff_col.values)\n    \n                # Filter out columns with type errors\n                filter_old_data = old_col_to_tuple.loc[:, ~old_col_to_tuple.columns.isin(type_error_col)]\n                filter_new_data = new_col_to_tuple.loc[:, ~new_col_to_tuple.columns.isin(type_error_col)]\n    \n                # # Merge and find differences\n                # if filter_new_data.equals(filter_old_data):\n                #     print(\"enter\")\n                #     data_match.append(f\"Database Data Match: {sql_type.replace('select * from ', '')}\")\n                # else:\n                try:\n                    df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n                    df_diff = df_diff[df_diff[\"_merge\"] != \"both\"]\n                    df_diff = df_diff.rename(columns={'_merge': 'database'})\n                    df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only',\n                                                                          str(new_database)).str.replace(\n                        'right_only', str(old_database))\n                except TypeError:\n                    sql_type_error_query = \"select * from \" + sql_type.replace('select * from ', '')\n                    sql_type_error_query_list.append(sql_type_error_query)\n                    allure.attach(f\"Table Name: {sql_type.replace('select * from ', '')}\",\n                                  name='Type Error in Database Table', attachment_type=allure.attachment_type.TEXT)\n                    continue\n    \n                if df_diff is not None and df_diff[\"database\"].isin([str(old_database), str(new_database)]).any():\n                    print(\"enter_2\")\n                    assert_flag = False\n                    df_diff_html = df_diff.to_html()\n                    allure.attach(df_diff_html,\n                                  name=f\"Difference between two Database tables: {sql_type.replace('select * from ', '')}\",\n                                  attachment_type=allure.attachment_type.HTML)\n                else:\n                    print(\"enter_3\")\n                    data_match.append(f\"Database Data Match: {sql_type.replace('select * from ', '')}\")\n    \n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(old_database))\n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(new_database))\n    \n        # Close database connections\n        DataBaseConnection.close_connection(old_db_connection)\n        DataBaseConnection.close_connection(new_db_connection)\n    \n        database_data_match = '\\n'.join(data_match)\n        allure.attach(str(database_data_match), name='Database Data Match',\n                      attachment_type=allure.attachment_type.TEXT)\n        missing_tables = '\\n'.join(missing_tables)\n        allure.attach(str(missing_tables), name='Missing Tables from database',\n                      attachment_type=allure.attachment_type.TEXT)\n        missing_column = '\\n'.join(missing_column)\n        allure.attach(str(missing_column), name='Missing Column in Database table',\n                      attachment_type=allure.attachment_type.TEXT)\n        database_column_datatype = '\\n'.join(column_data_type)\n        allure.attach(str(database_column_datatype), name='Database Columns Datatype not matching',\n                      attachment_type=allure.attachment_type.TEXT)\n    \n        if len(missing_tables) != 0:\n>           assert assert_flag, f\"{old_database} & {new_database} Database tables details are not matching\"\nE           AssertionError: amneal_dwi & amneal_migrated_dwi Database tables details are not matching\nE           assert False\n\ntests\\database\\test_db.py:244: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"load_env","time":{"start":1734005178837,"stop":1734005178838,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"hasContent":false,"attachmentStep":false,"stepsCount":0}],"testStage":{"status":"failed","statusMessage":"AssertionError: amneal_dwi & amneal_migrated_dwi Database tables details are not matching\nassert False","statusTrace":"self = <test_db.TestDataBaseConnection object at 0x000001BD2E41F110>\n\n    @pytest.mark.compare_database\n    def test_compare_database(self):\n        assert_flag = True\n        data_match = []\n        missing_tables = []\n        missing_column = []\n        column_data_type = []\n        sql_type_error_query_list = []\n        type_error_col = []\n    \n        with open('util/host_detail.json') as file:\n            data = json.load(file)\n    \n        old_database = data[\"old_dbname\"]\n        new_database = data[\"new_dbname\"]\n    \n        # Create database connections once\n        old_db_connection = DataBaseConnection.setup_connection(old_database)\n        new_db_connection = DataBaseConnection.setup_connection(new_database)\n    \n        for sql_query in Sql:\n            data_base_connect = DataBaseConnection.get_db_data(old_db_connection, sql_query.value)\n            data_base_connect1 = DataBaseConnection.get_db_data(new_db_connection, sql_query.value)\n    \n            old_tables = set(data_base_connect[\"sql_query_list\"])\n            new_tables = set(data_base_connect1[\"sql_query_list\"])\n    \n            # Tables in old database but not in new database\n            tables_in_old_not_in_new = old_tables - new_tables\n            for table in tables_in_old_not_in_new:\n                missing_tables.append(f\"Database: {old_database}, Table Name: {table.replace('select * from ', '')}\")\n    \n            # Tables in new database but not in old database\n            tables_in_new_not_in_old = new_tables - old_tables\n            for table in tables_in_new_not_in_old:\n                missing_tables.append(f\"Database: {new_database}, Table Name: {table.replace('select * from ', '')}\")\n    \n            # Tables present in both databases\n            data_query_list = list(old_tables & new_tables)\n    \n            for sql in data_query_list:\n                list_col = []\n                try:\n                    old_data = DataBaseConnection.get_db_data(old_db_connection, sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(old_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n                    continue\n                except Exception as e:\n                    assert_flag = False\n                    missing_tables.append(\n                        f\"Error fetching data from {old_database} for table {sql.replace('select * from ', '')}: {str(e)}\")\n                    continue\n    \n                try:\n                    new_data = DataBaseConnection.get_db_data(new_db_connection, sql)[\"db_data\"]\n                except psycopg2.errors.UndefinedTable:\n                    assert_flag = False\n                    missing_tables.append(\"Database: \" + str(new_database) + \",\" + \" Table Name : \" + str(\n                        sql.replace('select * from ', '')))\n                    continue\n                except Exception as e:\n                    assert_flag = False\n                    missing_tables.append(\n                        f\"Error fetching data from {new_database} for table {sql.replace('select * from ', '')}: {str(e)}\")\n                    continue\n    \n                if new_data is None or old_data is None:\n                    assert_flag = False\n                    missing_tables.append(f\"Data retrieval failed for table: {sql.replace('select * from ', '')}\")\n                    continue\n    \n                if new_data.columns.difference(old_data.columns).any():\n                    assert_flag = False\n                    diff_col = new_data.columns.difference(old_data.columns)\n                    missing_column.append(\"Instance: \" + str(old_database) + \",\" + \" Column: \" + str(\n                        diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                        sql.replace('select * from ', '')))\n    \n                if old_data.columns.difference(new_data.columns).any():\n                    assert_flag = False\n                    diff_col = old_data.columns.difference(new_data.columns)\n                    missing_column.append(\"Instance: \" + str(new_database) + \",\" + \" Column: \" + str(\n                        diff_col.values) + \",\" + ' Missing Column in Database table : ' + str(\n                        sql.replace('select * from ', '')))\n    \n                try:\n                    filter_new_data = new_data.loc[:, ~new_data.columns.isin(list_col)]\n                    filter_old_data = old_data.loc[:, ~old_data.columns.isin(list_col)]\n    \n                    df_diff = None\n                    if not filter_new_data.equals(filter_old_data):\n                        try:\n                            df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n                            df_diff = df_diff[df_diff['_merge'] != 'both']\n                            df_diff = df_diff.rename(columns={'_merge': 'database'})\n                            df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only',\n                                                                                  str(new_database)).str.replace(\n                                'right_only', str(old_database))\n                        except TypeError:\n                            sql_type_error_query = \"select * from \" + sql.replace('select * from ', '')\n                            sql_type_error_query_list.append(sql_type_error_query)\n                            allure.attach(\"Table Name : \" + str(sql.replace('select * from ', '')),\n                                          name='Type Error in Database Table',\n                                          attachment_type=allure.attachment_type.TEXT)\n                            pass\n    \n                        if df_diff is not None and df_diff[\"database\"].isin(\n                                [str(old_database), str(new_database)]).any():\n                            assert_flag = False\n                            df_diff_html = df_diff.to_html()\n                            allure.attach(df_diff_html, name='Difference Between Two Database tables : ' +\n                                                             str(sql.replace('select * from ', '')),\n                                          attachment_type=allure.attachment_type.HTML)\n                    else:\n                        data_match.append('Database Data Match : ' + str(sql.replace('select * from ', '')))\n                except Exception as e:\n                    print(e, sql)\n    \n            for sql_data_type in data_base_connect[\"sql_data_type_query_list\"]:\n                old_data = \\\n                    DataBaseConnection.get_db_data(old_db_connection, sql_data_type)[\"db_data\"]\n                new_data = \\\n                    DataBaseConnection.get_db_data(new_db_connection, sql_data_type)[\"db_data\"]\n                common_columns = None\n                if old_data is not None and new_data is not None:\n                    try:\n                        common_columns = set(old_data['column_name']).intersection(set(new_data['column_name']))\n                    except Exception as e:\n                        print(e, sql)\n                        continue\n                else:\n                    allure.attach(f\"Missing data for table: {sql_data_type}\", name='Missing Data',\n                                  attachment_type=allure.attachment_type.TEXT)\n    \n                try:\n                    for column in common_columns:\n                        db_type1 = old_data.loc[old_data['column_name'] == column, 'data_type'].iloc[0]\n                        db_type2 = new_data.loc[old_data['column_name'] == column, 'data_type'].iloc[0]\n                        if db_type1 != db_type2:\n                            assert_flag = False\n                            sql_table = \"select column_name, data_type from information_schema.columns where table_name = \"\n                            df = f\"From Table: {str(sql_data_type.replace(sql_table, ''))}, Column '{column}' has \" \\\n                                 f\"different datatypes: Database 1: {db_type1},  Database 2: {db_type2}\"\n                            column_data_type.append(df)\n                except Exception as e:\n                    print(e, sql)\n    \n            def dict_to_tuple(d):\n                if isinstance(d, dict):\n                    return tuple(sorted((k, dict_to_tuple(v)) for k, v in d.items()))\n                elif isinstance(d, list):\n                    return tuple(dict_to_tuple(x) for x in d)\n                else:\n                    return d\n    \n            for sql_type in sql_type_error_query_list:\n                print(sql_type, \"sql_error\")\n                old_data = DataBaseConnection.get_db_data(old_db_connection, sql_type)[\"db_data\"]\n                new_data = DataBaseConnection.get_db_data(new_db_connection, sql_type)[\"db_data\"]\n    \n                # Apply dict_to_tuple for JSON columns\n                old_col_to_tuple = old_data.applymap(\n                    lambda x: dict_to_tuple(x) if isinstance(x, dict) or isinstance(x, list) else x)\n                new_col_to_tuple = new_data.applymap(\n                    lambda x: dict_to_tuple(x) if isinstance(x, dict) or isinstance(x, list) else x)\n    \n                # Identify columns with type errors\n                diff_col = old_col_to_tuple.columns.difference(new_col_to_tuple.columns)\n                type_error_col.extend(diff_col.values)\n    \n                # Filter out columns with type errors\n                filter_old_data = old_col_to_tuple.loc[:, ~old_col_to_tuple.columns.isin(type_error_col)]\n                filter_new_data = new_col_to_tuple.loc[:, ~new_col_to_tuple.columns.isin(type_error_col)]\n    \n                # # Merge and find differences\n                # if filter_new_data.equals(filter_old_data):\n                #     print(\"enter\")\n                #     data_match.append(f\"Database Data Match: {sql_type.replace('select * from ', '')}\")\n                # else:\n                try:\n                    df_diff = pd.merge(filter_new_data, filter_old_data, how=\"outer\", indicator=True)\n                    df_diff = df_diff[df_diff[\"_merge\"] != \"both\"]\n                    df_diff = df_diff.rename(columns={'_merge': 'database'})\n                    df_diff[\"database\"] = df_diff[\"database\"].str.replace('left_only',\n                                                                          str(new_database)).str.replace(\n                        'right_only', str(old_database))\n                except TypeError:\n                    sql_type_error_query = \"select * from \" + sql_type.replace('select * from ', '')\n                    sql_type_error_query_list.append(sql_type_error_query)\n                    allure.attach(f\"Table Name: {sql_type.replace('select * from ', '')}\",\n                                  name='Type Error in Database Table', attachment_type=allure.attachment_type.TEXT)\n                    continue\n    \n                if df_diff is not None and df_diff[\"database\"].isin([str(old_database), str(new_database)]).any():\n                    print(\"enter_2\")\n                    assert_flag = False\n                    df_diff_html = df_diff.to_html()\n                    allure.attach(df_diff_html,\n                                  name=f\"Difference between two Database tables: {sql_type.replace('select * from ', '')}\",\n                                  attachment_type=allure.attachment_type.HTML)\n                else:\n                    print(\"enter_3\")\n                    data_match.append(f\"Database Data Match: {sql_type.replace('select * from ', '')}\")\n    \n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(old_database))\n                DataBaseConnection.close_connection(DataBaseConnection.setup_connection(new_database))\n    \n        # Close database connections\n        DataBaseConnection.close_connection(old_db_connection)\n        DataBaseConnection.close_connection(new_db_connection)\n    \n        database_data_match = '\\n'.join(data_match)\n        allure.attach(str(database_data_match), name='Database Data Match',\n                      attachment_type=allure.attachment_type.TEXT)\n        missing_tables = '\\n'.join(missing_tables)\n        allure.attach(str(missing_tables), name='Missing Tables from database',\n                      attachment_type=allure.attachment_type.TEXT)\n        missing_column = '\\n'.join(missing_column)\n        allure.attach(str(missing_column), name='Missing Column in Database table',\n                      attachment_type=allure.attachment_type.TEXT)\n        database_column_datatype = '\\n'.join(column_data_type)\n        allure.attach(str(database_column_datatype), name='Database Columns Datatype not matching',\n                      attachment_type=allure.attachment_type.TEXT)\n    \n        if len(missing_tables) != 0:\n>           assert assert_flag, f\"{old_database} & {new_database} Database tables details are not matching\"\nE           AssertionError: amneal_dwi & amneal_migrated_dwi Database tables details are not matching\nE           assert False\n\ntests\\database\\test_db.py:244: AssertionError","steps":[],"attachments":[{"uid":"2b8f39b8a5d87551","name":"Type Error in Database Table","source":"2b8f39b8a5d87551.txt","type":"text/plain","size":23},{"uid":"20abf825f22dabe","name":"Difference Between Two Database tables : email_templates","source":"20abf825f22dabe.html","type":"text/html","size":787628},{"uid":"1b87e7b0c47f8e47","name":"Type Error in Database Table","source":"1b87e7b0c47f8e47.txt","type":"text/plain","size":23},{"uid":"769cb5ba074261bf","name":"Type Error in Database Table","source":"769cb5ba074261bf.txt","type":"text/plain","size":29},{"uid":"24b1248dfc5d0b56","name":"Difference Between Two Database tables : users","source":"24b1248dfc5d0b56.html","type":"text/html","size":151304},{"uid":"b4de8d03a592d8b7","name":"Difference Between Two Database tables : task_execution_timers","source":"b4de8d03a592d8b7.html","type":"text/html","size":4053345},{"uid":"3780b24ce88840fb","name":"Type Error in Database Table","source":"3780b24ce88840fb.txt","type":"text/plain","size":23},{"uid":"11c3a7ada8573ad4","name":"Difference Between Two Database tables : databasechangelog","source":"11c3a7ada8573ad4.html","type":"text/html","size":43955},{"uid":"f93d5b187c924d27","name":"Type Error in Database Table","source":"f93d5b187c924d27.txt","type":"text/plain","size":24},{"uid":"483baa4bf064e0d1","name":"Difference Between Two Database tables : facilities","source":"483baa4bf064e0d1.html","type":"text/html","size":2540},{"uid":"aa820cf0e190c1d8","name":"Difference between two Database tables: parameters","source":"aa820cf0e190c1d8.html","type":"text/html","size":1249599},{"uid":"f68419008c0b4fa5","name":"Difference between two Database tables: automations","source":"f68419008c0b4fa5.html","type":"text/html","size":249635},{"uid":"c263e47fd29840f1","name":"Database Data Match","source":"c263e47fd29840f1.txt","type":"text/plain","size":2052},{"uid":"faa79e7c57839ec6","name":"Missing Tables from database","source":"faa79e7c57839ec6.txt","type":"text/plain","size":2193},{"uid":"c78503091bfc9834","name":"Missing Column in Database table","source":"c78503091bfc9834.txt","type":"text/plain","size":2010},{"uid":"a9daa66402377b18","name":"Database Columns Datatype not matching","source":"a9daa66402377b18.txt","type":"text/plain","size":127}],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":16,"hasContent":true,"attachmentStep":false,"stepsCount":0},"afterStages":[],"labels":[{"name":"tag","value":"compare_database"},{"name":"parentSuite","value":"tests.database"},{"name":"suite","value":"test_db"},{"name":"subSuite","value":"TestDataBaseConnection"},{"name":"host","value":"DESKTOP-ESU2KLG"},{"name":"thread","value":"9168-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.database.test_db"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":["compare_database"]},"source":"6c5a27f3b3eee3b2.json","parameterValues":[]}